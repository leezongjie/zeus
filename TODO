接口规范
RESTFUL：URL的资源与操作解耦，让URL更加符合语义，上百个接口也非常好管理，网上有很多文章讲得非常透彻，这玩意不是特别好理解，要多领悟，在项目中实践，就有矛塞盾开的感觉，这里不做详细介绍。

接口文档swagger：比起传统全手工写接口文档，swagger有统一的输出格式，不管是几个人写的；swagger采用写代码的方式来写接口文档，以前修改了代码，还必须打开wiki手工修改接口文档，现在只需要修改一下代码即可，程序员更愿意修改了，成本更低了，前端与其它调用者不会天天吼着，你这接口咋又变了，新加的字段是啥意思呀。

服务注册与发现 spring cloud eureka
服务接口改变后，再也不需要口头通知服务调用者了，因为调用者太多，你根本不知道他是谁，难免遗漏；可支持PHP。


消息队列
RocketMQ：一直纠结kafka与rocketMQ，最终选择了RocketMQ。

异步编程方式
为了性能上面的考虑，尽量使用异步编程，比如注册送优惠券，那么注册成功就可以给用户返回注册成功了，但是送优惠券可以是异步调用的，不阻塞注册的线程。

实时日志分析平台 ELK
微服务框架下，日志不可能还分散在各个服务节点上，必须有统一的日志中心。ELK是一个实时日志分析平台，就是将各个服务的日志汇总于日志中心，然后可以按照系统、节点等进行搜索，除上述搜索条件外，我们还在各个微服务实现了按照业务id（一次请求生成一个业务id）与用户id搜索日志，方便跟踪与定位问题。

统一配置中心 ETCD
当然可能有更加轻量级与好用的disconf或spring cloud config，但是我们有php开发的应用，以上二者都不支持。如果全是JAVA应用，采用disconf还是非常不错的。

测试
微服务接口测试工具postman
每个程序员都有这样的经历，刚上线，客户又反馈了bug，原来是我们修改某个功能代码的时候，导致了其它功能的bug，每次上线心里都没底；这就体现了接口测试的必须性，尤其是每次版本升级的时候，都需要执行一遍，以防修改某个接口导致其它接口报错，比手动测试靠谱许多。

部署
微服务的好基友：docker
docker已经家喻户晓了，这是继虚拟机以后，又一重大变革，将所有的单个微服务都放在docker中，这样你何时何地想部署，直接丢过去就OK了，快到爆。

负载均衡利器：docker swarm
用几句简单的命令就搞定了负载均衡，而且还可以平滑升级，版本升级的时候，大家就不用告诉客户：系统通知，某日某晚00:00-08:00我行处于系统升级维护中，大家不要去取钱哦，因为你可能取不出来，呵呵。

升级
数据库升级
升级前对数据库做物理或逻辑备份
数据库脚本不能含有删除或修改表与数据的语句，防止升级过程中旧业务报错
所有脚本上线前运维人员必须check，一些敏感词drop或delete
我们采用工具flyway，可以对数据库脚本进行版本控制。

持续集成
传统的版本升级，1.开发推代码并同时记录自己提交了哪些文件；2.项目经理根据svn审核文件，并打包成war包；3.投到测试环境让测试公司测试；4.中途修改了文件，可能需要重新打包；我都写不下去了，项目经理像个超人似的。

现在用持续集成（CI）非常简单，我们用的工具是Jenkins，推完代码，点几下按钮就完成了上线，不管是测试环境，还是生产环境都非常简单，不然项目经理核对文件眼睛都绿了。


网关API
在之前的章节中，我们已经深入地探讨了产品信息这个微服务的开发，这套模板同样也能够以相似的方式应用于这个电子商务网站的垂直分片中的其它每一种服务中。当系统的每个垂直分片中的各个组件被分解为一系列微服务的集合之后，该系统就可被视为一种完全分布式的微服务架构。但对于外部调用者，例如该电子商务网站的页面来说，这种方式也会产生一些复杂性，因为这些调用者从系统中获取的数据可能会横跨多个不同的微服务。如果不通过某种机制，将这些服务综合地重新组织为一种看起来具有整体性的API，那么每个客户端的调用者将不得不承担这种职责，它们将分别调用这些不同的数据集，并将它们重新组织为一种可重用的结构。这种方式对于调用者产生了很大的负责，因为他们必须建立大量的HTTP连接，以实现对某些数据集的聚合。这也意味着如果某个服务不可用或掉线，那么每个调用者将负责对数据缺失这一场景进行适当的处理。

用于微服务基础设施中的某种模式正在逐渐浮现，这种模式体现了一种网关API服务的概念，这种服务处于各个不同的后端服务的前方，并为调用者提供一种全面的、易于使用的API。继续以电子商务网站的例子进行讲解，当网站的某个访问者打算查看某个产品的详细信息时，为了生成产品信息视图的数据，需要四种服务参与其中。该网页不再对这些服务分别进行调用，而是访问该网关服务的某个聚合API的终结点，网关服务会代为调用底层服务，并将结果集进行合并，返回页面进行显示。从网页的角度来看，它只是发送了一个调用请求，就获得了显示页面所必须的完整数据。

这种方式还具有一个额外的好处，就是可以在调用者与后台服务之间更好地管理数据的传输。比方说，该网关服务在它的服务层可以实现某些逻辑，当对某个产品的信息的访问量很大的时候，它将不会在每个请求中都去调用相应的产品信息微服务，而是选择在某个预定义的时间段之内直接返回缓存中的数据。这种方式能够显著地提升性能，并减少网络负载。

同样重要的一点还在于对后台服务的可用性进行抽象。一旦发生某个后台服务不可用的情况下，网关服务能够明智地决定应该提供怎样的数据。现实这一点的方式有多种，而在网关服务中确保分布式系统的持久性这方面最引人注目的一种机制是由Netflix开发的名为Hystrix的类库。在Hystrix中有许多功能能够确保对故障的适应性，并且对于海量请求提供了性能方面的优化，但其中最吸引人的特性大概要数它对断路设计模式的实现了。具体来说，Hystrix能够观察到对某个后端服务的连接断开，在这种情况下它不会选择持续访问这个下线的服务，因为这会造成网络阻塞以及等待超时，而是打开这个服务的回路，将后续的请求委托给某个“后备”方法，让它接管这些调用。在底层，Hystrix会间隔式地检查该连接，查看该后台服务是否已经恢复了正常操作状态，如果服务已经恢复，那么它就会重新建立通信连接。

当回路打开的期间，网关服务能够任意选择返回给调用者的响应。可以使用某些“最后一次正常运行时”的正确数据集，也可以返回一个空响应，在头信息中告知调用者后端回路已经打开，或是以上两者的某种结合。Hystrix提供的适应性在任何一个具有一定复杂性的分布式系统中都是一种关键的组件。为了更直白地理解Hystrix的能力，我们再回头来看看这个电子商务中的产品垂直分片，其中必须调用四种服务，以获得产品信息视图中对应的数据。